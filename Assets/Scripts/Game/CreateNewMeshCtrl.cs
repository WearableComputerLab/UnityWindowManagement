using System;
using System.Collections;
using System.Collections.Generic;
using Events;
using UnityEngine;
using QFramework;
using uWindowCapture;
using System.Runtime.InteropServices;


// This script registers a series of events that will be used in other functional parts, especially in the thumbnail panel and the left panel.

public class CreateNewMeshCtrl : MonoBehaviour//Based on the mesh grid generated by the four points, mount the grid to a script above. Mainly used to correspond to some of his events.
{    

    // Start is called before the first frame update
    private Material _material;
    private bool isDisplay = false; //Determine whether the window is in unscreened mode, also in the update script   
    public UwcWindow uwcWindow;
    public TextureChange textureChange;
    public float time=0;
    public float timer = 0.05f;//Next, determine the timer used in the dynamic picture. The screen of uwc windows will be synchronized every 0.05 seconds.
    private string windowname;

    void Start()
    {
        textureChange = gameObject.GetComponent<TextureChange>();
        TypeEventSystem.Global.Register<EventCaptureDisPlay>(OnCaptureDisPlay);
        //This registered event is responsible for displaying the content (texture) of the capture window
        TypeEventSystem.Global.Register<EventChangeDisPlayMatTexture>(OnChangeDisPlayMatTextureHandler);
        //This registered event synchronizes the contents of the window, and after the event is sent, the registration accepts the response that sends the response.
        //If there are multiple windows open on the left, you can switch.
        TypeEventSystem.Global.Register<EventClearTexture>(OnClearTextureHandler);
        //remove the window texture,
        TypeEventSystem.Global.Register<EventHideCubeWindow>(OnHideCubeWindowHander);
        //Hide mesh when close window
        TypeEventSystem.Global.Register<EventShowCubeWindow>(OnShowCubeWindowHander);
        //show mesh
        _material = GetComponent<MeshRenderer>().material;
    }
    private void OnHideCubeWindowHander(EventHideCubeWindow obj)
    {
        FindObjectOfType<CreateNewMeshCtrl>().gameObject.GetComponent<Renderer>().DestroyGameObj();//Find the mesh, hide the mesh
        foreach (GameObject o in GameObject.FindGameObjectsWithTag("ClickTag"))//Find the balls and hide them one by one.
        {
            o.gameObject.GetComponent<Renderer>().DestroyGameObj();
        }
    }
    //When switching, it is always displayed at the beginning.

    private void OnShowCubeWindowHander(EventShowCubeWindow obj)
    {
        FindObjectOfType<CreateNewMeshCtrl>().gameObject.GetComponent<Renderer>().enabled = true;//find mesh, show mesh
        foreach (GameObject o in GameObject.FindGameObjectsWithTag("ClickTag"))//Find the balls and display them one by one.
        {
            o.gameObject.GetComponent<Renderer>().enabled = true;
        }
    }
    //responsible for the display window,


    private void OnClearTextureHandler(EventClearTexture obj)//Only responsible for clearing the texture, not responsible for clearing the mesh
    {
    //
        if (windowname==obj.windowName)//Determine whether it is the window you want to delete.
        {
            isDisplay = false;
            _material.mainTexture = null;//delete material
            
        }
    }
    

    private void OnCaptureDisPlay(EventCaptureDisPlay obj)
    {

        //The response is the method of LeftTabCell,
        isDisplay = false;//Make a judgment, because it is already a static picture on the left side, so the synchronization of 0.05s of the following Update is not required.
        windowname = obj.windowName;
        _material.mainTexture = TextureRotHelper.RoateTextureUpDown180(TextureRotHelper.CopyT2DToWrite(obj.texture2D));
        ////Flip screenshot upside down
    }
    private void OnChangeDisPlayMatTextureHandler(EventChangeDisPlayMatTexture obj)//Synchronize the contents of the window; by changing the texture on the created mesh,
    {
        // Changed the way this works, to only change the texture of the selected plane(screen).///

        //this code below diretly displays the window/texture over the mesh but applies the same texture to all the meshes
        //This event is sent when a thumbnail is selected.
       // isDisplay = true;
        //    uwcWindow = obj.Window;//Synchronize the selected uwc window. (put to the right)
         //   windowname = obj.windowName;//The name of the synchronized window
         //   _material.mainTexture = obj.texture2D;//The texture of the synchronized window (the static texture is placed on the left)

        //this code below ask the user to select a window from the side menu and makes the user double click a mesh to display that window
        if (textureChange.clicked)
        {
            //This event is sent when a thumbnail is selected.
            isDisplay = true;
            uwcWindow = obj.Window;//Synchronize the selected uwc window. (put to the right)
            windowname = obj.windowName;//The name of the synchronized window
            _material.mainTexture = obj.texture2D;//The texture of the synchronized window (the static texture is placed on the left)
        }
    }

    private Rect GetWindowRect(IntPtr window)
    {
        WinAPI.RECT rect;
        WinAPI.GetWindowRect(window, out rect);

        return new Rect(rect.Left, rect.Top, rect.Right - rect.Left, rect.Bottom - rect.Top);
    }


    // Update is called once per frame
    void Update()//Because what is needed is a dynamic picture, a judgment is made here.
    {
        if (Input.GetMouseButtonDown(0))
        {
            Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition);
            RaycastHit hit;

            if (Physics.Raycast(ray, out hit))
            {
                Vector2 localPoint = hit.textureCoord;
                Rect rect = GetWindowRect(WinAPI.GetForegroundWindow());

                WinAPI.POINT point;
                point.X = (int)(localPoint.x * rect.width);
                point.Y = (int)(localPoint.y * rect.height);
                WinAPI.ScreenToClient(WinAPI.GetForegroundWindow(), ref point);

                WinAPI.SendMessage(WinAPI.GetForegroundWindow(), WinAPI.WM_LBUTTONDOWN, IntPtr.Zero, new IntPtr(point.Y * 0x10000 + point.X));
                WinAPI.SendMessage(WinAPI.GetForegroundWindow(), WinAPI.WM_LBUTTONUP, IntPtr.Zero, new IntPtr(point.Y * 0x10000 + point.X));
            }
        }

        if (isDisplay)//If it is in the mode without screenshots, synchronize the screen of the uwc window every 0.05s.
        {
            time -= Time.deltaTime;
            if (time<=0)
            {
                
                if (uwcWindow!=null)
                {
                    this.uwcWindow.RequestCapture();
                    
                }
                if (uwcWindow != null&& uwcWindow.texture)//if empty and has a material
                {                    
                    _material.mainTexture = uwcWindow.texture;//directly into dynamic
                }
                time = timer;
            }
        }
    }

    private void OnDestroy()
    {
        TypeEventSystem.Global.UnRegister<EventCaptureDisPlay>(OnCaptureDisPlay);
        TypeEventSystem.Global.UnRegister<EventChangeDisPlayMatTexture>(OnChangeDisPlayMatTextureHandler);
        TypeEventSystem.Global.UnRegister<EventClearTexture>(OnClearTextureHandler);
        TypeEventSystem.Global.UnRegister<EventHideCubeWindow>(OnHideCubeWindowHander);
        TypeEventSystem.Global.UnRegister<EventShowCubeWindow>(OnShowCubeWindowHander);

    }
}
